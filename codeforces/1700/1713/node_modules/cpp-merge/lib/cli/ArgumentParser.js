"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionArgumentExpectedError = exports.UnknownOptionError = exports.UnknownArgumentError = exports.ArgumentError = void 0;
const assert_1 = __importDefault(require("assert"));
const errors_1 = require("../common/errors");
const HelpFormatter_1 = __importDefault(require("./HelpFormatter"));
class ArgumentError extends errors_1.TraceError {
    constructor(message, argument) {
        super(message);
        this.argument = argument;
    }
}
exports.ArgumentError = ArgumentError;
class UnknownArgumentError extends ArgumentError {
    constructor(argument, message = `Unknown argument '${argument}'`) {
        super(message, argument);
    }
}
exports.UnknownArgumentError = UnknownArgumentError;
class UnknownOptionError extends ArgumentError {
    constructor(argument, message = `Unknown option '${argument}'`) {
        super(message, argument);
    }
}
exports.UnknownOptionError = UnknownOptionError;
class OptionArgumentExpectedError extends ArgumentError {
    constructor(option, message = `Option '${option}' requires a value`) {
        super(message, option);
    }
}
exports.OptionArgumentExpectedError = OptionArgumentExpectedError;
class ArgumentParser {
    constructor(params) {
        this.helpFormatter = new HelpFormatter_1.default();
        this.arguments = [];
        this.options = [];
        this.programName = params.programName;
        this.description = params.description;
    }
    addArgument(argument) {
        this.arguments.push(argument);
    }
    addOption(option) {
        this.options.push(option);
    }
    parseArguments(args) {
        const argumentsToParse = [...args];
        const parsedArguments = {};
        const parsedOptions = {};
        let argumentIndex = 0;
        while (argumentsToParse.length > 0) {
            const argument = argumentsToParse.shift();
            (0, assert_1.default)(argument);
            if (this.isOption(argument)) {
                const { name, value } = this.parseOption(argument, argumentsToParse);
                parsedOptions[name] = value;
                continue;
            }
            if (argumentIndex >= this.arguments.length) {
                throw new UnknownArgumentError(argument);
            }
            const argumentName = this.arguments[argumentIndex].name;
            parsedArguments[argumentName] = argument;
            ++argumentIndex;
        }
        return {
            arguments: parsedArguments,
            options: parsedOptions
        };
    }
    isOption(argument) {
        return argument.startsWith("-");
    }
    parseOption(argument, args) {
        const option = this.findOption(argument);
        if (!option) {
            throw new UnknownOptionError(argument);
        }
        if (!option.value) {
            return { name: option.name, value: "" };
        }
        const value = args.shift();
        if (!value) {
            throw new OptionArgumentExpectedError(argument);
        }
        return { name: option.name, value: value };
    }
    findOption(option) {
        return this.options.find((opt) => {
            return opt.options.find(o => o === option);
        });
    }
    formatHelp() {
        return this.helpFormatter.formatHelp(this.programName, this.description, this.arguments, this.options);
    }
}
exports.default = ArgumentParser;
//# sourceMappingURL=ArgumentParser.js.map